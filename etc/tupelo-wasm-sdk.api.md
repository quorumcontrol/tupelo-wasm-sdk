## API Report File for "tupelo-wasm-sdk"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import CID from 'cids';
import { CurrentState } from 'tupelo-messages/signatures/signatures_pb';
import { Envelope } from 'tupelo-messages';
import EventEmitter from 'events';
import { NotaryGroup } from 'tupelo-messages/config/config_pb';
import { NotaryGroup as NotaryGroup_2 } from 'tupelo-messages';
import OldCId from 'cids';
import { Signature } from 'tupelo-messages/signatures/signatures_pb';
import { TokenPayload } from 'tupelo-messages/transactions/transactions_pb';
import { Transaction } from 'tupelo-messages';
import { Transaction as Transaction_2 } from 'tupelo-messages/transactions/transactions_pb';

// @public
export class ChainTree extends Dag {
    constructor(opts: IChainTreeInitializer);
    id(): Promise<string | null>;
    // (undocumented)
    key?: EcdsaKey;
    static newEmptyTree: (store: IBlockService, key: EcdsaKey) => Promise<ChainTree>;
    resolveData(path: string): Promise<import("./dag/dag").IResolveResponse>;
    // (undocumented)
    store: IBlockService;
}

// @public
export const CID: typeof OldCId;

// @public
export class Community extends EventEmitter {
    // Warning: (ae-forgotten-export) The symbol "IRepo" needs to be exported by the entry point index.d.ts
    constructor(node: IP2PNode, group: NotaryGroup_2, repo: IRepo);
    // (undocumented)
    bitswap: ICallbackBitswap;
    // (undocumented)
    blockservice: IBlockService;
    getCurrentState(did: string): Promise<import("tupelo-messages/signatures/signatures_pb").CurrentState>;
    getTip(did: string): Promise<CID_2>;
    // (undocumented)
    group: NotaryGroup_2;
    nextUpdate(): Promise<unknown>;
    // (undocumented)
    node: IP2PNode;
    playTransactions(tree: ChainTree, transactions: Transaction_2[]): Promise<import("tupelo-messages/signatures/signatures_pb").CurrentState>;
    // (undocumented)
    sendTokenAndGetPayload(tree: ChainTree, tx: Transaction_2): Promise<import("tupelo-messages").TokenPayload>;
    start(): Promise<Community>;
    // (undocumented)
    stop(): Promise<void>;
    // (undocumented)
    subscribeToTips(): Promise<void>;
    // (undocumented)
    tip?: CID_2;
    // (undocumented)
    waitForStart(): Promise<Community>;
}

// @public (undocumented)
export namespace Community {
    export function freshLocalTestCommunity(repo?: Repo): Promise<Community>;
    export function getDefault(repo?: Repo): Promise<Community>;
    export function setDefault(community: Community): void;
}

// @beta
export class CommunityMessenger {
    constructor(name: string, shards: number, key: EcdsaKey, localIdentifier: Uint8Array, pubsub: IPubSub);
    // (undocumented)
    localIdentifier: Uint8Array;
    // (undocumented)
    name: string;
    // (undocumented)
    publish(topic: string, payload: Uint8Array): Promise<unknown>;
    // (undocumented)
    subscribe(topic: string, subscriber: Function): Promise<unknown>;
    unsubscribe(topic: string, subscriber: Function): Promise<unknown>;
}

// @public
export class Dag {
    constructor(tip: CID_2, store: IBlockService);
    // (undocumented)
    dagStore: IDagStore;
    get(cid: CID_2): Promise<Object>;
    // (undocumented)
    resolve(path: Array<string> | string): Promise<IResolveResponse>;
    resolveAt(tip: CID_2, path: Array<string> | string): Promise<IResolveResponse>;
    // (undocumented)
    tip: CID_2;
}

// @public
export const defaultNotaryGroup: import("tupelo-messages").NotaryGroup;

// @public
export class EcdsaKey {
    constructor(publicKeyBits: Uint8Array, privateKeyBits?: Uint8Array);
    // (undocumented)
    static fromBytes: (bytes: Uint8Array) => Promise<EcdsaKey>;
    static generate: () => Promise<EcdsaKey>;
    // (undocumented)
    keyAddr(): Promise<string>;
    static passPhraseKey: (phrase: Uint8Array, salt: Uint8Array) => Promise<EcdsaKey>;
    // (undocumented)
    privateKey?: Uint8Array;
    // (undocumented)
    publicKey: Uint8Array;
}

// @public
export const establishTokenTransaction: (name: string, maximum: number) => Transaction_2;

// @public
export interface IBitSwap {
    // (undocumented)
    get(cid: CID_2, callback: Function): void;
    // (undocumented)
    put(block: IBlock, callback: Function): void;
    // (undocumented)
    start(callback: Function): void;
    // (undocumented)
    stop(callback: Function): void;
}

// @public
export interface IBlock {
    // (undocumented)
    cid: CID_2;
    // (undocumented)
    data: Buffer;
}

// @public
export interface IBlockService {
    // (undocumented)
    delete(cid: CID_2): Promise<any>;
    // (undocumented)
    get(cid: CID_2): Promise<IBlock>;
    // (undocumented)
    hasExchange(): boolean;
    // (undocumented)
    put(block: IBlock): Promise<any>;
    // (undocumented)
    setExchange(bitswap: IBitSwap): void;
    // (undocumented)
    unsetExchange(): void;
}

// @public
export interface ICallbackBitswap {
    // (undocumented)
    get(cid: CID_2, cb: Function): void;
    // (undocumented)
    getMany(cids: CID_2[], callback: Function): void;
    // (undocumented)
    getWantlist(): any;
    // (undocumented)
    ledgerForPeer(peerId: any): Object;
    // (undocumented)
    peers(): any;
    // (undocumented)
    put(block: IBlock, cb: Function): void;
    // (undocumented)
    putMany(blocks: IBlock[], callback: Function): void;
    // (undocumented)
    start(cb: Function): void;
    // (undocumented)
    stat(): any;
    // (undocumented)
    stop(cb: Function): void;
    // (undocumented)
    wantlistForPeer(peerID: any): any;
}

// @public
export interface IChainTreeInitializer {
    // (undocumented)
    key?: EcdsaKey;
    // (undocumented)
    store: IBlockService;
    // (undocumented)
    tip: CID_2;
}

// @public
export interface IDagStore {
    // (undocumented)
    get(cid: CID_2): Promise<Object>;
    // Warning: (ae-forgotten-export) The symbol "IExtendedDagStoreIterator" needs to be exported by the entry point index.d.ts
    // 
    // (undocumented)
    resolve(cid: CID_2, path: string): IExtendedDagStoreIterator;
}

// @public
export interface INodeOptions {
    // (undocumented)
    bootstrapAddresses?: string[];
}

// @public
export interface IP2PNode {
    // (undocumented)
    emit(evt: string): null;
    // (undocumented)
    isStarted(): boolean;
    // (undocumented)
    on(evt: string, cb: Function): null;
    // (undocumented)
    once(evt: string, cb: Function): null;
    // (undocumented)
    pubsub: any;
    // (undocumented)
    start(cb: Function): null;
    // (undocumented)
    state: any;
    // (undocumented)
    stop(): null;
}

// @public
export interface IPubSub {
    // (undocumented)
    publish(topic: string, data: Uint8Array, cb: Function): null;
    // (undocumented)
    subscribe(topic: string, onMsg: Function, cb: Function): null;
    // (undocumented)
    unsubscribe(topic: string, onMsg: Function, cb: Function): null;
}

// @public
export interface IPubSubMessage {
    // (undocumented)
    data: Uint8Array;
    // (undocumented)
    from: string;
    // (undocumented)
    seqno: Uint8Array;
    // (undocumented)
    topicIDs: string[];
}

// @public
export interface IQuery {
    // (undocumented)
    prefix: string;
}

// @public
export interface IResolveResponse {
    // (undocumented)
    remainderPath: string[];
    // (undocumented)
    value: any;
}

// @public (undocumented)
export const mintTokenTransaction: (name: string, amount: number) => Transaction_2;

// @public (undocumented)
export namespace p2p {
    // (undocumented)
    export function createNode(opts: INodeOptions): Promise<IP2PNode>;
}

// @public (undocumented)
export const receiveTokenTransaction: (sendId: string, tip: Uint8Array, signature: Signature, leaves: Uint8Array[]) => Transaction_2;

// @public
export const receiveTokenTransactionFromPayload: (payload: TokenPayload) => Transaction_2;

// @public
export class Repo {
    constructor(name: string, opts?: RepoOpts);
    // (undocumented)
    close(): Promise<any>;
    // (undocumented)
    get(key: IKey): Promise<any>;
    // (undocumented)
    init(opts: any): Promise<any>;
    // (undocumented)
    open(): Promise<any>;
    // Warning: (ae-forgotten-export) The symbol "IKey" needs to be exported by the entry point index.d.ts
    // 
    // (undocumented)
    put(key: IKey, val: Uint8Array): Promise<any>;
    // (undocumented)
    query(query: IQuery): any;
    // (undocumented)
    repo: any;
}

// @public
export interface RepoOpts {
    // (undocumented)
    lock: string;
    // Warning: (ae-forgotten-export) The symbol "IStorageBackendOpts" needs to be exported by the entry point index.d.ts
    // 
    // (undocumented)
    storageBackends: IStorageBackendOpts;
}

// @public (undocumented)
export const sendTokenTransaction: (sendId: string, name: string, amount: number, destinationChainId: string) => Transaction_2;

// @public
export const setDataTransaction: (path: string, value: any) => Transaction_2;

// @public
export const setOwnershipTransaction: (newOwnerKeys: string[]) => Transaction_2;

// @public
export function tomlToNotaryGroup(tomlString: string): NotaryGroup;

// @public
export namespace Tupelo {
    // (undocumented)
    export function ecdsaPubkeyToAddress(pubKey: Uint8Array): Promise<string>;
    // (undocumented)
    export function ecdsaPubkeyToDid(pubKey: Uint8Array): Promise<string>;
    // (undocumented)
    export function generateKey(): Promise<Uint8Array[]>;
    // Warning: (ae-forgotten-export) The symbol "IGetCurrentStateOptions" needs to be exported by the entry point index.d.ts
    // 
    // (undocumented)
    export function getCurrentState(opts: IGetCurrentStateOptions): Promise<CurrentState>;
    // (undocumented)
    export function getSendableEnvelopeBytes(env: Envelope, key: EcdsaKey): Promise<Uint8Array>;
    // (undocumented)
    export function hashToShardNumber(topic: string, maxShards: number): Promise<number>;
    // (undocumented)
    export function keyFromPrivateBytes(bytes: Uint8Array): Promise<Uint8Array[]>;
    // (undocumented)
    export function newEmptyTree(store: IBlockService, publicKey: Uint8Array): Promise<CID_2>;
    // (undocumented)
    export function passPhraseKey(phrase: Uint8Array, salt: Uint8Array): Promise<Uint8Array[]>;
    // (undocumented)
    export function playTransactions(publisher: IPubSub, notaryGroup: NotaryGroup, tree: ChainTree, transactions: Transaction[]): Promise<CurrentState>;
    // Warning: (ae-forgotten-export) The symbol "ITransactionPayloadOpts" needs to be exported by the entry point index.d.ts
    // 
    // (undocumented)
    export function tokenPayloadForTransaction(opts: ITransactionPayloadOpts): Promise<TokenPayload>;
}

// @public
export class WrappedBitswap {
    constructor(bitswap: ICallbackBitswap);
    // (undocumented)
    delete(cid: CID_2): Promise<unknown>;
    // (undocumented)
    get(cid: CID_2): Promise<IBlock>;
    // (undocumented)
    getMany(cids: CID_2[]): Promise<unknown>;
    // (undocumented)
    getWantlist(): any;
    // (undocumented)
    ledgerForPeer(peerID: any): Object;
    // (undocumented)
    peers(): any;
    // (undocumented)
    put(block: IBlock): Promise<any>;
    // (undocumented)
    putMany(blocks: IBlock[]): Promise<unknown>;
    // (undocumented)
    start(): () => Promise<unknown>;
    // (undocumented)
    stat(): any;
    // (undocumented)
    stop(): () => Promise<unknown>;
    // (undocumented)
    wantlistForPeer(peerID: any): any;
}

// @public
export class WrappedBlockService implements IBlockService {
    // Warning: (ae-forgotten-export) The symbol "ICallbackBlockService" needs to be exported by the entry point index.d.ts
    constructor(blockservice: ICallbackBlockService);
    // (undocumented)
    delete(cid: CID_2): Promise<any>;
    // (undocumented)
    get(cid: CID_2): Promise<IBlock>;
    // (undocumented)
    hasExchange(): boolean;
    // (undocumented)
    put(block: IBlock): Promise<any>;
    // (undocumented)
    setExchange(bitswap: IBitSwap): void;
    // (undocumented)
    unsetExchange(): void;
}


```
